# 8. Errors and Exceptions[](https://docs.python.org/3/tutorial/errors.html#errors-and-exceptions "Permalink to this headline")

Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: _syntax errors_ and _exceptions_.

## 8.1. Syntax Errors[](https://docs.python.org/3/tutorial/errors.html#syntax-errors "Permalink to this headline")

Syntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python:


```python

while True print('Hello world')
File "<stdin>", line 1
   while True print('Hello world')
                   ^
SyntaxError: invalid syntax

```

The parser repeats the offending line and displays a little ‘arrow’ pointing at the earliest point in the line where the error was detected. The error is caused by (or at least detected at) the token _preceding_ the arrow: in the example, the error is detected at the function [`print()`](https://docs.python.org/3/library/functions.html#print "print"), since a colon (`':'`) is missing before it. File name and line number are printed so you know where to look in case the input came from a script.

## 8.2. Exceptions[](https://docs.python.org/3/tutorial/errors.html#exceptions "Permalink to this headline")

Even if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called _exceptions_ and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here:

```python

>>> 10 * (1/0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
>>> 4 + spam*3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate str (not "int") to str

```

The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are [`ZeroDivisionError`](https://docs.python.org/3/library/exceptions.html#ZeroDivisionError "ZeroDivisionError"), [`NameError`](https://docs.python.org/3/library/exceptions.html#NameError "NameError") and [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "TypeError"). The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords).

The rest of the line provides detail based on the type of exception and what caused it.

The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input.

[Built-in Exceptions](https://docs.python.org/3/library/exceptions.html#bltin-exceptions) lists the built-in exceptions and their meanings.

## 8.3. Handling Exceptions[](https://docs.python.org/3/tutorial/errors.html#handling-exceptions "Permalink to this headline")

It is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using Control-C or whatever the operating system supports); note that a user-generated interruption is signalled by raising the [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt") exception.

```python
>>> while True:
...     try:
...         x = int(input("Please enter a number: "))
...         break
...     except ValueError:
...         print("Oops!  That was no valid number.  Try again...")
...
```

The [`try`](https://docs.python.org/3/reference/compound_stmts.html#try) statement works as follows.

- First, the _try clause_ (the statement(s) between the [`try`](https://docs.python.org/3/reference/compound_stmts.html#try) and [`except`](https://docs.python.org/3/reference/compound_stmts.html#except) keywords) is executed.
    
- If no exception occurs, the _except clause_ is skipped and execution of the [`try`](https://docs.python.org/3/reference/compound_stmts.html#try) statement is finished.
    
- If an exception occurs during execution of the [`try`](https://docs.python.org/3/reference/compound_stmts.html#try) clause, the rest of the clause is skipped. Then, if its type matches the exception named after the [`except`](https://docs.python.org/3/reference/compound_stmts.html#except) keyword, the _except clause_ is executed, and then execution continues after the try/except block.
    
- If an exception occurs which does not match the exception named in the _except clause_, it is passed on to outer [`try`](https://docs.python.org/3/reference/compound_stmts.html#try) statements; if no handler is found, it is an _unhandled exception_ and execution stops with an error message.
    

A [`try`](https://docs.python.org/3/reference/compound_stmts.html#try) statement may have more than one _except clause_, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding _try clause_, not in other handlers of the same `try` statement. An _except clause_ may name multiple exceptions as a parenthesized tuple, for example:

... except (RuntimeError, TypeError, NameError):
...     pass

A class in an [`except`](https://docs.python.org/3/reference/compound_stmts.html#except) clause is compatible with an exception if it is the same class or a base class thereof (but not the other way around — an _except clause_ listing a derived class is not compatible with a base class). For example, the following code will print B, C, D in that order:

```
`class B(Exception):
    pass

class C(B):
    pass

class D(C):
    pass

for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D")
    except C:
        print("C")
    except B:
        print("B")
````
Note that if the _except clauses_ were reversed (with `except B` first), it would have printed B, B, B — the first matching _except clause_ is triggered.

When an exception occurs, it may have associated values, also known as the exception’s _arguments_. The presence and types of the arguments depend on the exception type.

The _except clause_ may specify a variable after the exception name. The variable is bound to the exception instance which typically has an `args` attribute that stores the arguments. For convenience, builtin exception types define [`__str__()`](https://docs.python.org/3/reference/datamodel.html#object.__str__ "object.__str__") to print all the arguments without explicitly accessing `.args`.

>>>

>>> try:
...     raise Exception('spam', 'eggs')
... except Exception as inst:
...     print(type(inst))    # the exception type
...     print(inst.args)     # arguments stored in .args
...     print(inst)          # __str__ allows args to be printed directly,
...                          # but may be overridden in exception subclasses
...     x, y = inst.args     # unpack args
...     print('x =', x)
...     print('y =', y)
...
<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs

The exception’s [`__str__()`](https://docs.python.org/3/reference/datamodel.html#object.__str__ "object.__str__") output is printed as the last part (‘detail’) of the message for unhandled exceptions.

[`BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException "BaseException") is the common base class of all exceptions. One of its subclasses, [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "Exception"), is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "Exception") are not typically handled, because they are used to indicate that the program should terminate. They include [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit "SystemExit") which is raised by [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit "sys.exit") and [`KeyboardInterrupt`](https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt "KeyboardInterrupt") which is raised when a user wishes to interrupt the program.

[`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "Exception") can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on.

The most common pattern for handling [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception "Exception") is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well):

import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print("OS error:", err)
except ValueError:
    print("Could not convert data to an integer.")
except Exception as err:
    print(f"Unexpected {err=}, {type(err)=}")
    raise